## OpenMetadata Manifest

Our manifest file is defined as a [JSON Schema](https://github.com/open-metadata/OpenMetadata/blob/main/openmetadata-spec/src/main/resources/json/schema/metadataIngestion/storage/containerMetadataConfig.json),
and can look like this:

<CodePreview>

<ContentPanel>

<ContentSection id={1} title="Entries" lines="1-3">

**Entries**: We need to add a list of `entries`. Each inner JSON structure will be ingested as a child container of the top-level one. In this case, we will be ingesting 7 children.

</ContentSection>

<ContentSection id={2} title="Simple Container" lines="4-9">

**Simple Container**: The simplest container we can have would be structured, but without partitions. Note that we still need to bring information about:

- **dataPath**: Where we can find the data. This should be a path relative to the top-level container.
- **structureFormat**: What is the format of the data we are going to find. This information will be used to read the data.
- **separator**: Optionally, for delimiter-separated formats such as CSV, you can specify the separator to use when reading the file. If you don't, we will use `,` for CSV and `/t` for TSV files.

After ingesting this container, we will bring in the schema of the data in the `dataPath`.

</ContentSection>

<ContentSection id={3} title="Partitioned Container" lines="10-14">

**Partitioned Container**: We can ingest partitioned data without bringing in any further details.

By informing the `isPartitioned` field as `true`, we'll flag the container as `Partitioned`. We will be reading the source files schemas', but won't add any other information.

</ContentSection>

<ContentSection id={4} title="Single-Partition Container" lines="15-23">

**Single-Partition Container**: We can bring partition information by specifying the `partitionColumns`. Their definition is based on the [JSON Schema](https://github.com/open-metadata/OpenMetadata/blob/main/openmetadata-spec/src/main/resources/json/schema/entity/data/table.json#L232) definition for table columns. The minimum required information is the `name` and `dataType`.

When passing `partitionColumns`, these values will be added to the schema, on top of the inferred information from the files.

</ContentSection>

<ContentSection id={5} title="Multiple-Partition Container" lines="24-33">

**Multiple-Partition Container**: We can add multiple columns as partitions.

Note how in the example we even bring our custom `displayName` for the column `dataTypeDisplay` for its type.

Again, this information will be added on top of the inferred schema from the data files.

</ContentSection>

<ContentSection id={6} title="Automated Container Ingestion" lines="34-37">

**Automated Container Ingestion**: Registering all the data paths one by one can be a time consuming job, to make the automated structure container ingestion you can provide the depth at which all the data is available.

For example, suppose following is the file hierarchy within your bucket:

```
# prefix/depth1/depth2/depth3
athena_service/my_database_a/my_schema_a/table_a/date=01-01-2025/data.parquet
athena_service/my_database_a/my_schema_a/table_a/date=02-01-2025/data.parquet
athena_service/my_database_a/my_schema_a/table_b/date=01-01-2025/data.parquet
athena_service/my_database_a/my_schema_a/table_b/date=02-01-2025/data.parquet

athena_service/my_database_b/my_schema_a/table_a/date=01-01-2025/data.parquet
athena_service/my_database_b/my_schema_a/table_a/date=02-01-2025/data.parquet
athena_service/my_database_b/my_schema_a/table_b/date=01-01-2025/data.parquet
athena_service/my_database_b/my_schema_a/table_b/date=02-01-2025/data.parquet
```

All table folders containing actual data are at depth 3. When you specify `depth: 3` in the manifest entry, all following paths will get registered as containers in OpenMetadata with this single entry:

```
athena_service/my_database_a/my_schema_a/table_a
athena_service/my_database_a/my_schema_a/table_b
athena_service/my_database_b/my_schema_a/table_a
athena_service/my_database_b/my_schema_a/table_b
```

This saves effort - 1 entry instead of 4 individual entries.

</ContentSection>

<ContentSection id={7} title="Unstructured Container" lines="38-45">

**Unstructured Container**: OpenMetadata supports ingesting unstructured files like images, PDFs, etc. We support fetching the file names, size, and tags associated with such files.

- To ingest a **single unstructured file**: specify the full path of the file in `dataPath`
- To ingest **specific file types** (e.g., `pdf` & `png`): provide the folder name in `dataPath` and list of extensions in `unstructuredFormats`
- To ingest **all unstructured files** regardless of type: provide the folder name in `dataPath` and `["*"]` in `unstructuredFormats`

</ContentSection>

</ContentPanel>

<CodePanel fileName="openmetadata.json">

```json
{
  "entries": [
    {
      "dataPath": "transactions/",
      "structureFormat": "csv",
      "separator": ","
    },
    {
      "dataPath": "orders/",
      "structureFormat": "parquet",
      "isPartitioned": true
    },
    {
      "dataPath": "users/",
      "structureFormat": "parquet",
      "isPartitioned": true,
      "partitionColumns": [
        {
          "name": "signup_date",
          "dataType": "DATE"
        }
      ]
    },
    {
      "dataPath": "events/",
      "structureFormat": "parquet",
      "isPartitioned": true,
      "partitionColumns": [
        {
          "name": "event_date",
          "dataType": "DATE"
        },
        {
          "name": "region",
          "dataType": "STRING"
        }
      ]
    },
    {
      "depth": 3,
      "structureFormat": "parquet"
    },
    {
      "dataPath": "reports/report.pdf"
    },
    {
      "dataPath": "documents/",
      "unstructuredFormats": ["pdf", "png", "jpg"]
    }
  ]
}
```

</CodePanel>

</CodePreview>


### Global Manifest

You can also manage a **single** manifest file to centralize the ingestion process for any container, named `openmetadata_storage_manifest.json`.

<CodePreview>

<ContentPanel>

<ContentSection id={1} title="Existing Fields" lines="1-15">

The fields shown above (`dataPath`, `structureFormat`, `isPartitioned`, etc.) are still valid and work the same way in the global manifest.

</ContentSection>

<ContentSection id={2} title="Container Name" lines="1-15">

**Container Name**: Since we are using a single manifest for all your containers, the field `containerName` will help us identify which container (or Bucket in S3, etc.) contains the presented information.

Each entry in the global manifest must include a `containerName` to specify which bucket or container it belongs to.

</ContentSection>

</ContentPanel>

<CodePanel fileName="openmetadata_storage_manifest.json">

```json
{
  "entries": [
    {
      "containerName": "my-s3-bucket-1",
      "dataPath": "transactions/",
      "structureFormat": "csv",
      "separator": ","
    },
    {
      "containerName": "my-s3-bucket-1",
      "dataPath": "orders/",
      "structureFormat": "parquet",
      "isPartitioned": true
    },
    {
      "containerName": "my-s3-bucket-2",
      "dataPath": "users/",
      "structureFormat": "parquet",
      "isPartitioned": true,
      "partitionColumns": [
        {
          "name": "signup_date",
          "dataType": "DATE"
        }
      ]
    },
    {
      "containerName": "my-s3-bucket-2",
      "dataPath": "events/",
      "structureFormat": "json"
    }
  ]
}
```

</CodePanel>

</CodePreview>

You can also keep local manifests `openmetadata.json` in each container, but if possible, we will always try to pick up the global manifest during the ingestion.
